"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = require("compiler");
const project_crawler_1 = require("../projects/project_crawler");
const script_1 = require("./script");
class Build extends script_1.Script {
    autoComplete() {
        throw new Error('Method not implemented.');
    }
    help() {
        return {
            description: 'Builds stuff'
        };
    }
    async run(args, context) {
        const allProjects = await project_crawler_1.projectCrawler.findProjects(context.workspaceRoot, context);
        const selectedProjects = this.getSelectedProjects(args, allProjects, context);
        if (selectedProjects.length) {
            await compiler_1.compiler.compile(selectedProjects, allProjects, context, args);
        }
        else {
            context.uiLogger.error('None of the provided names were matching a project. Not building.');
        }
        return {};
    }
    getSelectedProjects(args, projects, context) {
        if (!args.list.length) {
            return projects;
        }
        else {
            const selectedProjects = [];
            projects.forEach((p) => {
                if (args.list.includes(p.resolvedConfig.name)) {
                    selectedProjects.push(p);
                }
            });
            if (selectedProjects.length < args.list.length) {
                const notFoundNames = [];
                const selectedProjectNames = selectedProjects.map((p) => p.resolvedConfig.name);
                args.list.forEach((a) => {
                    if (!selectedProjectNames.includes(a)) {
                        notFoundNames.push(a);
                    }
                });
                context.uiLogger.warn(`No project(s) with the name(s) ${notFoundNames.join(', ')} could be located. Skipping these arguments.`);
            }
            return selectedProjects;
        }
    }
}
exports.Build = Build;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJ1aWxkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImJ1aWxkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tcGlsZXJfMSA9IHJlcXVpcmUoXCJjb21waWxlclwiKTtcbmNvbnN0IHByb2plY3RfY3Jhd2xlcl8xID0gcmVxdWlyZShcIi4uL3Byb2plY3RzL3Byb2plY3RfY3Jhd2xlclwiKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZShcIi4vc2NyaXB0XCIpO1xuY2xhc3MgQnVpbGQgZXh0ZW5kcyBzY3JpcHRfMS5TY3JpcHQge1xuICAgIGF1dG9Db21wbGV0ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBoZWxwKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdCdWlsZHMgc3R1ZmYnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJ1bihhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGFsbFByb2plY3RzID0gYXdhaXQgcHJvamVjdF9jcmF3bGVyXzEucHJvamVjdENyYXdsZXIuZmluZFByb2plY3RzKGNvbnRleHQud29ya3NwYWNlUm9vdCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUHJvamVjdHMgPSB0aGlzLmdldFNlbGVjdGVkUHJvamVjdHMoYXJncywgYWxsUHJvamVjdHMsIGNvbnRleHQpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRQcm9qZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbXBpbGVyXzEuY29tcGlsZXIuY29tcGlsZShzZWxlY3RlZFByb2plY3RzLCBhbGxQcm9qZWN0cywgY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnVpTG9nZ2VyLmVycm9yKCdOb25lIG9mIHRoZSBwcm92aWRlZCBuYW1lcyB3ZXJlIG1hdGNoaW5nIGEgcHJvamVjdC4gTm90IGJ1aWxkaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0ZWRQcm9qZWN0cyhhcmdzLCBwcm9qZWN0cywgY29udGV4dCkge1xuICAgICAgICBpZiAoIWFyZ3MubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUHJvamVjdHMgPSBbXTtcbiAgICAgICAgICAgIHByb2plY3RzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5saXN0LmluY2x1ZGVzKHAucmVzb2x2ZWRDb25maWcubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQcm9qZWN0cy5wdXNoKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkUHJvamVjdHMubGVuZ3RoIDwgYXJncy5saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdEZvdW5kTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFByb2plY3ROYW1lcyA9IHNlbGVjdGVkUHJvamVjdHMubWFwKChwKSA9PiBwLnJlc29sdmVkQ29uZmlnLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFyZ3MubGlzdC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRQcm9qZWN0TmFtZXMuaW5jbHVkZXMoYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kTmFtZXMucHVzaChhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQudWlMb2dnZXIud2FybihgTm8gcHJvamVjdChzKSB3aXRoIHRoZSBuYW1lKHMpICR7bm90Rm91bmROYW1lcy5qb2luKCcsICcpfSBjb3VsZCBiZSBsb2NhdGVkLiBTa2lwcGluZyB0aGVzZSBhcmd1bWVudHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRQcm9qZWN0cztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQnVpbGQgPSBCdWlsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVluVnBiR1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SmlkV2xzWkM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEhWRFFVRnZRenRCUVVOd1F5eHBSVUZCTmtRN1FVRkROMFFzY1VOQlFXdERPMEZCUTJ4RExFMUJRV0VzUzBGQlRTeFRRVUZSTEdWQlFVMDdTVUZETjBJc1dVRkJXVHRSUVVOU0xFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNlVUpCUVhsQ0xFTkJRVU1zUTBGQlF6dEpRVU12UXl4RFFVRkRPMGxCUTBRc1NVRkJTVHRSUVVOQkxFOUJRVTg3V1VGRFNDeFhRVUZYTEVWQlFVVXNZMEZCWXp0VFFVTTVRaXhEUVVGRE8wbEJRMDRzUTBGQlF6dEpRVU5FTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFOUJRVTg3VVVGRGJrSXNUVUZCVFN4WFFVRlhMRWRCUVVjc1RVRkJUU3huUTBGQll5eERRVUZETEZsQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1lVRkJZU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFGQlEzUkdMRTFCUVUwc1owSkJRV2RDTEVkQlFVY3NTVUZCU1N4RFFVRkRMRzFDUVVGdFFpeERRVUZETEVsQlFVa3NSVUZCUlN4WFFVRlhMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRE9VVXNTVUZCU1N4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZEZWtJc1RVRkJUU3h0UWtGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4blFrRkJaMElzUlVGQlJTeFhRVUZYTEVWQlFVVXNUMEZCVHl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xTkJRM2hGTzJGQlEwazdXVUZEUkN4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eHRSVUZCYlVVc1EwRkJReXhEUVVGRE8xTkJReTlHTzFGQlEwUXNUMEZCVHl4RlFVRkZMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJRMFFzYlVKQlFXMUNMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFBRVUZQTzFGQlEzWkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlR0WlFVTnVRaXhQUVVGUExGRkJRVkVzUTBGQlF6dFRRVU51UWp0aFFVTkpPMWxCUTBRc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4RlFVRkZMRU5CUVVNN1dVRkROVUlzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hGUVVGRk8yZENRVU51UWl4SlFVRkpMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVU3YjBKQlF6TkRMR2RDUVVGblFpeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRwUWtGRE5VSTdXVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOSUxFbEJRVWtzWjBKQlFXZENMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZPMmRDUVVNMVF5eE5RVUZOTEdGQlFXRXNSMEZCUnl4RlFVRkZMRU5CUVVNN1owSkJRM3BDTEUxQlFVMHNiMEpCUVc5Q0xFZEJRVWNzWjBKQlFXZENMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1kwRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTm9SaXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hGUVVGRk8yOUNRVU53UWl4SlFVRkpMRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRk8zZENRVU51UXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzNGQ1FVTjZRanRuUWtGRFRDeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRTQ3hQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4clEwRkJhME1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc09FTkJRVGhETEVOQlFVTXNRMEZCUXp0aFFVTnVTVHRaUVVORUxFOUJRVThzWjBKQlFXZENMRU5CUVVNN1UwRkRNMEk3U1VGRFRDeERRVUZETzBOQlEwbzdRVUUxUTBRc2MwSkJORU5ESW4wPSJdfQ==